//! Golden tests for new motif-rs features validated against stumpy reference data.
//!
//! Each test loads a JSON file generated by `scripts/generate_golden_features.py`
//! and compares our implementation's output against stumpy's reference output.

use motif_rs::{
    find_snippets, mpdist, ostinato, stimp, AampEngine, EuclideanEngine, MatrixProfile,
    MatrixProfileConfig, ZNormalizedEuclidean,
};
use serde::Deserialize;
use std::fs;

const EPSILON: f64 = 1e-6;

// ─── helpers ──────────────────────────────────────────────────────────────────

fn load_json(filename: &str) -> String {
    let path = format!("tests/golden_data/{filename}");
    fs::read_to_string(&path).unwrap_or_else(|_| {
        panic!(
            "Golden data file not found: {path}. Run: python scripts/generate_golden_features.py"
        )
    })
}

/// Treat values > 1e300 as infinity (JSON uses 1e308 sentinel for inf).
fn is_sentinel_inf(v: f64) -> bool {
    v.is_infinite() || v > 1e300
}

fn assert_profile_match(name: &str, rust: &[f64], stumpy: &[f64], epsilon: f64) {
    assert_eq!(
        rust.len(),
        stumpy.len(),
        "{name}: length mismatch: rust={} vs stumpy={}",
        rust.len(),
        stumpy.len()
    );

    let mut max_diff = 0.0_f64;
    let mut max_diff_idx = 0;

    for (i, (r, s)) in rust.iter().zip(stumpy).enumerate() {
        if is_sentinel_inf(*r) && is_sentinel_inf(*s) {
            continue;
        }
        let diff = (r - s).abs();
        if diff > max_diff {
            max_diff = diff;
            max_diff_idx = i;
        }
    }

    assert!(
        max_diff < epsilon,
        "{name}: max diff = {max_diff:.2e} at index {max_diff_idx} \
         (rust={}, stumpy={}), epsilon={epsilon:.0e}",
        rust[max_diff_idx],
        stumpy[max_diff_idx],
    );

    eprintln!("  {name}: max_diff = {max_diff:.2e} (epsilon = {epsilon:.0e})");
}

fn assert_topk_match(name: &str, rust: &[Vec<f64>], stumpy: &[Vec<f64>], epsilon: f64) {
    assert_eq!(
        rust.len(),
        stumpy.len(),
        "{name}: subsequence count mismatch"
    );
    for (i, (rd, sd)) in rust.iter().zip(stumpy).enumerate() {
        assert_eq!(
            rd.len(),
            sd.len(),
            "{name}: k-count mismatch at subsequence {i}"
        );
    }

    let (max_pos, max_diff) = rust
        .iter()
        .zip(stumpy)
        .enumerate()
        .flat_map(|(i, (rd, sd))| {
            rd.iter()
                .zip(sd)
                .enumerate()
                .filter(|(_, (r, s))| !(is_sentinel_inf(**r) && is_sentinel_inf(**s)))
                .map(move |(j, (r, s))| ((i, j), (r - s).abs()))
        })
        .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
        .unwrap_or(((0, 0), 0.0));

    assert!(
        max_diff < epsilon,
        "{name}: max diff = {max_diff:.2e} at ({}, {}), epsilon={epsilon:.0e}",
        max_pos.0,
        max_pos.1,
    );
    eprintln!("  {name}: max_diff = {max_diff:.2e} (epsilon = {epsilon:.0e})");
}

// ─── AAMP ─────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct AampGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
}

#[test]
fn test_aamp_vs_stumpy() {
    eprintln!("Testing AAMP (non-normalized Euclidean) vs stumpy...");
    let golden: AampGolden = serde_json::from_str(&load_json("aamp_sine_wave.json")).unwrap();

    let engine = AampEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match("aamp/profile", &mp.profile, &golden.profile, EPSILON);
}

// ─── AB-Join ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct AbJoinGolden {
    ts_a: Vec<f64>,
    ts_b: Vec<f64>,
    m: usize,
    #[allow(dead_code)]
    n_a: usize,
    #[allow(dead_code)]
    n_b: usize,
    profile_a: Vec<f64>,
    #[allow(dead_code)]
    index_a: Vec<i64>,
    profile_b: Vec<f64>,
    #[allow(dead_code)]
    index_b: Vec<i64>,
}

#[test]
fn test_ab_join_vs_stumpy() {
    eprintln!("Testing AB-Join vs stumpy...");
    let golden: AbJoinGolden =
        serde_json::from_str(&load_json("ab_join_sine_square.json")).unwrap();

    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let (join_a, join_b) = engine.ab_join(&golden.ts_a, &golden.ts_b);

    assert_profile_match(
        "ab_join/profile_a",
        &join_a.distances,
        &golden.profile_a,
        EPSILON,
    );
    assert_profile_match(
        "ab_join/profile_b",
        &join_b.distances,
        &golden.profile_b,
        EPSILON,
    );
}

// ─── Top-k ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct TopKGolden {
    ts: Vec<f64>,
    m: usize,
    k: usize,
    distances: Vec<Vec<f64>>,
    #[allow(dead_code)]
    indices: Vec<Vec<i64>>,
}

#[test]
fn test_topk_vs_stumpy() {
    eprintln!("Testing Top-k vs stumpy...");
    let golden: TopKGolden = serde_json::from_str(&load_json("topk_sine_wave.json")).unwrap();

    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let topk = engine.compute_topk(&golden.ts, golden.k);

    assert_eq!(topk.k, golden.k, "k mismatch");
    assert_eq!(
        topk.distances.len(),
        golden.distances.len(),
        "number of subsequences mismatch"
    );

    // Compare top-1 (nearest neighbor) distances — should match exactly
    let rust_top1: Vec<f64> = topk.distances.iter().map(|d| d[0]).collect();
    let stumpy_top1: Vec<f64> = golden.distances.iter().map(|d| d[0]).collect();
    assert_profile_match("topk/top1_distances", &rust_top1, &stumpy_top1, EPSILON);

    // Compare all k distances per subsequence
    assert_topk_match(
        "topk/all_distances",
        &topk.distances,
        &golden.distances,
        EPSILON,
    );
}

// ─── Discords ─────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct DiscordEntry {
    idx: usize,
    distance: f64,
}

#[derive(Deserialize)]
struct DiscordsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
    discords: Vec<DiscordEntry>,
}

#[test]
fn test_discords_vs_stumpy() {
    eprintln!("Testing Discord detection vs stumpy...");
    let golden: DiscordsGolden =
        serde_json::from_str(&load_json("discords_synthetic.json")).unwrap();

    // First: verify our STOMP matches stumpy's profile on this anomalous signal
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match(
        "discords/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    // Second: run find_discords and compare top discords
    let k = golden.discords.len();
    let our_discords = motif_rs::find_discords(&mp, k);

    assert_eq!(
        our_discords.len(),
        k,
        "discord count mismatch: got {}, expected {k}",
        our_discords.len()
    );

    // The top discord should be near the injected anomaly
    // Note: exact indices may differ due to tie-breaking, but the top discord
    // should be close to the same position and have the same distance
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    for (i, (ours, theirs)) in our_discords.iter().zip(&golden.discords).enumerate() {
        let idx_diff = (ours.idx as isize - theirs.idx as isize).unsigned_abs();
        let dist_diff = (ours.distance - theirs.distance).abs();
        assert!(
            idx_diff <= ez,
            "discord #{i}: index mismatch: ours={}, stumpy={}, diff={idx_diff} > ez={ez}",
            ours.idx,
            theirs.idx
        );
        assert!(
            dist_diff < EPSILON,
            "discord #{i}: distance mismatch: ours={}, stumpy={}, diff={dist_diff:.2e}",
            ours.distance,
            theirs.distance
        );
    }
    eprintln!("  discords: all {k} discords match within exclusion zone and epsilon");
}

// ─── Motifs ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MotifsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
    #[allow(dead_code)]
    motifs: Vec<serde_json::Value>,
}

#[test]
fn test_motifs_profile_vs_stumpy() {
    eprintln!("Testing Motifs (profile validation) vs stumpy...");
    let golden: MotifsGolden = serde_json::from_str(&load_json("motifs_synthetic.json")).unwrap();

    // Verify our STOMP matches stumpy's profile on the motif signal
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match(
        "motifs/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    // Run find_motifs to verify it doesn't panic and returns reasonable results
    let our_motifs = motif_rs::find_motifs(&mp, 3);
    eprintln!(
        "  motifs: found {} motifs (stumpy found {} with its different criteria)",
        our_motifs.len(),
        golden.motifs.len()
    );

    // Verify motifs are sorted by distance (ascending)
    for w in our_motifs.windows(2) {
        assert!(
            w[0].distance <= w[1].distance,
            "motifs not sorted: {} > {}",
            w[0].distance,
            w[1].distance
        );
    }

    // Verify motif distances are finite and positive
    for m in &our_motifs {
        assert!(m.distance.is_finite(), "motif distance is not finite");
        assert!(m.distance >= 0.0, "motif distance is negative");
        assert_ne!(m.idx_a, m.idx_b, "motif pair should have distinct indices");
    }
}

// ─── FLUSS ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct FlussGolden {
    ts: Vec<f64>,
    m: usize,
    #[allow(dead_code)]
    n: usize,
    #[allow(dead_code)]
    #[serde(rename = "L")]
    l: usize,
    profile_index: Vec<i64>,
    cac: Vec<f64>,
    #[allow(dead_code)]
    regime_locs: Vec<usize>,
}

#[test]
fn test_fluss_cac_vs_stumpy() {
    eprintln!("Testing FLUSS CAC vs stumpy...");
    let golden: FlussGolden = serde_json::from_str(&load_json("fluss_regime_change.json")).unwrap();

    // Construct a MatrixProfile from stumpy's profile_index so we test the
    // FLUSS algorithm in isolation from any STOMP tie-breaking differences.
    let n_subs = golden.profile_index.len();
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    let mut mp = MatrixProfile::new(n_subs, golden.m, ez);
    for (i, &idx) in golden.profile_index.iter().enumerate() {
        mp.profile_index[i] = idx as usize;
    }

    let seg = motif_rs::fluss(&mp, 1);
    let excl_zone = 5 * golden.m;

    // Length should match
    assert_eq!(
        seg.cac.len(),
        golden.cac.len(),
        "FLUSS CAC length mismatch: ours={}, stumpy={}",
        seg.cac.len(),
        golden.cac.len()
    );

    // All values should be in [0, 1]
    for (i, &v) in seg.cac.iter().enumerate() {
        assert!((0.0..=1.0).contains(&v), "CAC[{i}] = {v} out of [0, 1]");
    }

    // Edges should be nullified to 1.0
    for i in 0..excl_zone.min(seg.cac.len()) {
        assert!(
            (seg.cac[i] - 1.0).abs() < 1e-10,
            "FLUSS CAC not nullified at left edge index {i}: {}",
            seg.cac[i]
        );
    }
    for i in (n_subs - excl_zone).max(0)..n_subs {
        assert!(
            (seg.cac[i] - 1.0).abs() < 1e-10,
            "FLUSS CAC not nullified at right edge index {i}: {}",
            seg.cac[i]
        );
    }
    eprintln!("  fluss: edge nullification verified");

    // Our CAC and stumpy's CAC should have the same shape (Spearman rank
    // correlation) even though absolute values differ due to normalization.
    // Both should identify the same regime boundary position.
    // Note: stumpy normalizes with a beta distribution IAC, we use min(i+1, n-i).
    let valid_ours: Vec<f64> = seg.cac[excl_zone..n_subs - excl_zone].to_vec();
    let valid_stumpy: Vec<f64> = golden.cac[excl_zone..n_subs - excl_zone].to_vec();

    // Find the argmin of both CAC curves — should be in similar positions
    let our_min_idx = valid_ours
        .iter()
        .enumerate()
        .min_by(|a, b| a.1.partial_cmp(b.1).unwrap())
        .map(|(i, _)| i + excl_zone)
        .unwrap();
    let stumpy_min_idx = valid_stumpy
        .iter()
        .enumerate()
        .min_by(|a, b| a.1.partial_cmp(b.1).unwrap())
        .map(|(i, _)| i + excl_zone)
        .unwrap();

    let idx_diff = (our_min_idx as isize - stumpy_min_idx as isize).unsigned_abs();
    eprintln!(
        "  fluss/cac: our argmin={our_min_idx}, stumpy argmin={stumpy_min_idx}, diff={idx_diff}"
    );

    // Argmin positions should be close (within 2*m of each other)
    let tolerance = 2 * golden.m;
    assert!(
        idx_diff <= tolerance,
        "FLUSS CAC argmin differs: ours={our_min_idx}, stumpy={stumpy_min_idx}, \
         diff={idx_diff} > tolerance={tolerance}"
    );

    // Pearson correlation between the two CACs should be high
    let n_valid = valid_ours.len() as f64;
    let mean_ours = valid_ours.iter().sum::<f64>() / n_valid;
    let mean_stumpy = valid_stumpy.iter().sum::<f64>() / n_valid;

    let mut cov = 0.0;
    let mut var_ours = 0.0;
    let mut var_stumpy = 0.0;
    for (o, s) in valid_ours.iter().zip(&valid_stumpy) {
        let do_ = o - mean_ours;
        let ds = s - mean_stumpy;
        cov += do_ * ds;
        var_ours += do_ * do_;
        var_stumpy += ds * ds;
    }
    let correlation = cov / (var_ours.sqrt() * var_stumpy.sqrt());
    eprintln!("  fluss/cac: Pearson correlation with stumpy = {correlation:.4}");

    assert!(
        correlation > 0.85,
        "FLUSS CAC correlation with stumpy too low: {correlation:.4} (expected > 0.85)"
    );
}

// ─── End-to-end FLUSS with our STOMP ─────────────────────────────────────────

#[test]
fn test_fluss_end_to_end() {
    eprintln!("Testing FLUSS end-to-end (our STOMP + our FLUSS)...");
    let golden: FlussGolden = serde_json::from_str(&load_json("fluss_regime_change.json")).unwrap();

    // Run our full pipeline: STOMP → FLUSS
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);
    let seg = motif_rs::fluss(&mp, 1);

    // The CAC minimum should be near the regime change at index ~500
    // (the signal transitions from sine to sawtooth at ts[500]).
    // Convention: LOW CAC = regime boundary.
    let excl_zone = 5 * golden.m;
    let valid_cac: Vec<(usize, f64)> = seg
        .cac
        .iter()
        .enumerate()
        .filter(|(i, _)| *i >= excl_zone && *i < seg.cac.len() - excl_zone)
        .map(|(i, &v)| (i, v))
        .collect();

    let (min_idx, min_val) = valid_cac
        .iter()
        .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
        .unwrap();

    eprintln!("  fluss/e2e: CAC minimum at index {min_idx} (value = {min_val:.4})");

    // The minimum should be in the neighborhood of the regime change
    // Allow a wide margin since STOMP tie-breaking may shift the exact position
    // and subsequence boundary is at ~475-500 for m=25
    let regime_change = 500;
    let margin = 100; // ±100 indices
    assert!(
        (*min_idx as isize - regime_change as isize).unsigned_abs() < margin,
        "FLUSS e2e: CAC minimum at {min_idx}, expected near {regime_change} (±{margin})"
    );
}

// ─── Snippets ────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct SnippetsGolden {
    ts: Vec<f64>,
    m: usize,
    k: usize,
    indices: Vec<usize>,
    profiles: Vec<Vec<f64>>,
    fractions: Vec<f64>,
    areas: Vec<f64>,
    regimes: Vec<usize>,
}

#[test]
fn test_snippets_vs_stumpy() {
    eprintln!("Testing Snippets vs stumpy...");
    let golden: SnippetsGolden =
        serde_json::from_str(&load_json("snippets_multi_regime.json")).unwrap();

    let result = find_snippets(&golden.ts, golden.m, golden.k);

    // Indices should match exactly
    assert_eq!(
        result.indices, golden.indices,
        "snippets: indices mismatch: ours={:?}, stumpy={:?}",
        result.indices, golden.indices
    );
    eprintln!("  snippets/indices: match exactly {:?}", result.indices);

    // Profiles should match within epsilon
    assert_eq!(result.profiles.len(), golden.profiles.len());
    for (i, (ours, theirs)) in result.profiles.iter().zip(&golden.profiles).enumerate() {
        assert_profile_match(&format!("snippets/profile_{i}"), ours, theirs, EPSILON);
    }

    // Fractions should match within epsilon
    for (i, (ours, theirs)) in result.fractions.iter().zip(&golden.fractions).enumerate() {
        let diff = (ours - theirs).abs();
        assert!(
            diff < EPSILON,
            "snippets/fraction_{i}: mismatch: ours={ours}, stumpy={theirs}, diff={diff:.2e}"
        );
    }
    eprintln!(
        "  snippets/fractions: {:?} (stumpy: {:?})",
        result.fractions, golden.fractions
    );

    // Areas should match within epsilon
    for (i, (ours, theirs)) in result.areas.iter().zip(&golden.areas).enumerate() {
        let diff = (ours - theirs).abs();
        // Areas are sums over n_subs elements, so allow proportionally larger tolerance
        let area_eps = EPSILON * golden.ts.len() as f64;
        assert!(
            diff < area_eps,
            "snippets/area_{i}: mismatch: ours={ours}, stumpy={theirs}, diff={diff:.2e}"
        );
    }
    eprintln!("  snippets/areas: match within tolerance");

    // Regimes should match exactly (since profiles and indices match)
    assert_eq!(result.regimes, golden.regimes, "snippets: regimes mismatch");
    eprintln!("  snippets/regimes: match exactly");
}

// ─── MPdist ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MpdistGolden {
    ts_a: Vec<f64>,
    ts_b: Vec<f64>,
    m: usize,
    dist_default: f64,
    dist_custom_005: f64,
    dist_self: f64,
}

#[test]
fn test_mpdist_vs_stumpy() {
    eprintln!("Testing MPdist vs stumpy...");
    let golden: MpdistGolden = serde_json::from_str(&load_json("mpdist_sine_mixed.json")).unwrap();

    // Test default percentage
    let d_default = mpdist::<ZNormalizedEuclidean>(&golden.ts_a, &golden.ts_b, golden.m, None);
    let diff_default = (d_default - golden.dist_default).abs();
    eprintln!(
        "  mpdist/default: ours={d_default:.6}, stumpy={:.6}, diff={diff_default:.2e}",
        golden.dist_default
    );
    assert!(
        diff_default < EPSILON,
        "mpdist default: diff={diff_default:.2e} > epsilon={EPSILON:.0e}"
    );

    // Test custom percentage=0.05
    let d_custom = mpdist::<ZNormalizedEuclidean>(&golden.ts_a, &golden.ts_b, golden.m, Some(0.05));
    let diff_custom = (d_custom - golden.dist_custom_005).abs();
    eprintln!(
        "  mpdist/custom_005: ours={d_custom:.6}, stumpy={:.6}, diff={diff_custom:.2e}",
        golden.dist_custom_005
    );
    assert!(
        diff_custom < EPSILON,
        "mpdist custom 0.05: diff={diff_custom:.2e} > epsilon={EPSILON:.0e}"
    );

    // Test self-distance (should be ~0)
    let d_self = mpdist::<ZNormalizedEuclidean>(&golden.ts_a, &golden.ts_a, golden.m, None);
    eprintln!(
        "  mpdist/self: ours={d_self:.6}, stumpy={:.6}",
        golden.dist_self
    );
    assert!(
        d_self < 1e-4,
        "mpdist self-distance should be ~0, got {d_self}"
    );
}

// ─── SCRUMP ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct ScrumpGolden {
    ts: Vec<f64>,
    m: usize,
    exact_profile: Vec<f64>,
    #[allow(dead_code)]
    approx_profile_100: Vec<f64>,
}

#[test]
fn test_scrump_exact_vs_stumpy() {
    eprintln!("Testing SCRUMP (percentage=1.0 → exact STOMP) vs stumpy...");
    let golden: ScrumpGolden = serde_json::from_str(&load_json("scrump_sine_wave.json")).unwrap();

    // SCRUMP at percentage=1.0 should match exact STOMP exactly
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.scrump(&golden.ts, 1.0);

    assert_profile_match(
        "scrump/exact_profile",
        &mp.profile,
        &golden.exact_profile,
        EPSILON,
    );
}

// ─── Ostinato ────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct OstinatoGolden {
    ts_list: Vec<Vec<f64>>,
    m: usize,
    radius: f64,
    ts_idx: usize,
    subseq_idx: usize,
}

#[test]
fn test_ostinato_vs_stumpy() {
    eprintln!("Testing Ostinato vs stumpy...");
    let golden: OstinatoGolden =
        serde_json::from_str(&load_json("ostinato_consensus.json")).unwrap();

    let ts_refs: Vec<&[f64]> = golden.ts_list.iter().map(|v| v.as_slice()).collect();
    let result = ostinato::<ZNormalizedEuclidean>(&ts_refs, golden.m);

    eprintln!(
        "  ostinato: ours=(radius={:.6}, ts_idx={}, subseq_idx={}), \
         stumpy=(radius={:.6}, ts_idx={}, subseq_idx={})",
        result.radius,
        result.ts_index,
        result.subsequence_index,
        golden.radius,
        golden.ts_idx,
        golden.subseq_idx,
    );

    // Radius should be close to stumpy's
    let radius_diff = (result.radius - golden.radius).abs();
    assert!(
        radius_diff < EPSILON,
        "ostinato radius: diff={radius_diff:.2e} > epsilon={EPSILON:.0e}"
    );

    // Series index should match
    assert_eq!(
        result.ts_index, golden.ts_idx,
        "ostinato ts_index mismatch: ours={}, stumpy={}",
        result.ts_index, golden.ts_idx
    );

    // Subsequence index should match (or be within exclusion zone)
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    let idx_diff = result.subsequence_index.abs_diff(golden.subseq_idx);
    assert!(
        idx_diff <= ez,
        "ostinato subseq_idx: ours={}, stumpy={}, diff={idx_diff} > ez={ez}",
        result.subsequence_index,
        golden.subseq_idx,
    );
}

// ─── STIMP ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct StimpGolden {
    ts: Vec<f64>,
    min_m: usize,
    max_m: usize,
    windows: Vec<usize>,
    profiles: Vec<Vec<f64>>,
    #[allow(dead_code)]
    indices: Vec<Vec<i64>>,
}

#[test]
fn test_stimp_vs_stumpy() {
    eprintln!("Testing STIMP vs stumpy...");
    let golden: StimpGolden = serde_json::from_str(&load_json("stimp_pan_profile.json")).unwrap();

    // Use exact STOMP (percentage=None) for precise comparison
    let pan = stimp::<ZNormalizedEuclidean>(&golden.ts, golden.min_m, golden.max_m, Some(1), None);

    // Window sizes should match
    assert_eq!(pan.windows, golden.windows, "STIMP window sizes mismatch");

    // Compare normalized profiles for each window size
    for (wi, m) in pan.windows.iter().enumerate() {
        assert_profile_match(
            &format!("stimp/profile_m{m}"),
            &pan.profiles[wi],
            &golden.profiles[wi],
            EPSILON,
        );
    }
    eprintln!(
        "  stimp: all {} window sizes match within epsilon",
        pan.windows.len()
    );
}
