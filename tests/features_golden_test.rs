//! Golden tests for new motif-rs features validated against stumpy reference data.
//!
//! Each test loads a JSON file generated by `scripts/generate_golden_features.py`
//! and compares our implementation's output against stumpy's reference output.

use motif_rs::{
    allc, find_matches, find_snippets, mass, mdl, mmotifs, mpdist, mstump, ostinato, stimp,
    subspace, AampEngine, EuclideanEngine, MatrixProfile, MatrixProfileConfig,
    ZNormalizedEuclidean,
};
use serde::Deserialize;
use std::fs;

const EPSILON: f64 = 1e-6;

// ─── helpers ──────────────────────────────────────────────────────────────────

fn load_json(filename: &str) -> String {
    let path = format!("tests/golden_data/{filename}");
    fs::read_to_string(&path).unwrap_or_else(|_| {
        panic!(
            "Golden data file not found: {path}. Run: python scripts/generate_golden_features.py"
        )
    })
}

/// Treat values > 1e300 as infinity (JSON uses 1e308 sentinel for inf).
fn is_sentinel_inf(v: f64) -> bool {
    v.is_infinite() || v > 1e300
}

fn assert_profile_match(name: &str, rust: &[f64], stumpy: &[f64], epsilon: f64) {
    assert_eq!(
        rust.len(),
        stumpy.len(),
        "{name}: length mismatch: rust={} vs stumpy={}",
        rust.len(),
        stumpy.len()
    );

    let mut max_diff = 0.0_f64;
    let mut max_diff_idx = 0;

    for (i, (r, s)) in rust.iter().zip(stumpy).enumerate() {
        if is_sentinel_inf(*r) && is_sentinel_inf(*s) {
            continue;
        }
        let diff = (r - s).abs();
        if diff > max_diff {
            max_diff = diff;
            max_diff_idx = i;
        }
    }

    assert!(
        max_diff < epsilon,
        "{name}: max diff = {max_diff:.2e} at index {max_diff_idx} \
         (rust={}, stumpy={}), epsilon={epsilon:.0e}",
        rust[max_diff_idx],
        stumpy[max_diff_idx],
    );

    eprintln!("  {name}: max_diff = {max_diff:.2e} (epsilon = {epsilon:.0e})");
}

fn assert_topk_match(name: &str, rust: &[Vec<f64>], stumpy: &[Vec<f64>], epsilon: f64) {
    assert_eq!(
        rust.len(),
        stumpy.len(),
        "{name}: subsequence count mismatch"
    );
    for (i, (rd, sd)) in rust.iter().zip(stumpy).enumerate() {
        assert_eq!(
            rd.len(),
            sd.len(),
            "{name}: k-count mismatch at subsequence {i}"
        );
    }

    let (max_pos, max_diff) = rust
        .iter()
        .zip(stumpy)
        .enumerate()
        .flat_map(|(i, (rd, sd))| {
            rd.iter()
                .zip(sd)
                .enumerate()
                .filter(|(_, (r, s))| !(is_sentinel_inf(**r) && is_sentinel_inf(**s)))
                .map(move |(j, (r, s))| ((i, j), (r - s).abs()))
        })
        .max_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
        .unwrap_or(((0, 0), 0.0));

    assert!(
        max_diff < epsilon,
        "{name}: max diff = {max_diff:.2e} at ({}, {}), epsilon={epsilon:.0e}",
        max_pos.0,
        max_pos.1,
    );
    eprintln!("  {name}: max_diff = {max_diff:.2e} (epsilon = {epsilon:.0e})");
}

// ─── AAMP ─────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct AampGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
}

#[test]
fn test_aamp_vs_stumpy() {
    eprintln!("Testing AAMP (non-normalized Euclidean) vs stumpy...");
    let golden: AampGolden = serde_json::from_str(&load_json("aamp_sine_wave.json")).unwrap();

    let engine = AampEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match("aamp/profile", &mp.profile, &golden.profile, EPSILON);
}

// ─── AB-Join ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct AbJoinGolden {
    ts_a: Vec<f64>,
    ts_b: Vec<f64>,
    m: usize,
    #[allow(dead_code)]
    n_a: usize,
    #[allow(dead_code)]
    n_b: usize,
    profile_a: Vec<f64>,
    #[allow(dead_code)]
    index_a: Vec<i64>,
    profile_b: Vec<f64>,
    #[allow(dead_code)]
    index_b: Vec<i64>,
}

#[test]
fn test_ab_join_vs_stumpy() {
    eprintln!("Testing AB-Join vs stumpy...");
    let golden: AbJoinGolden =
        serde_json::from_str(&load_json("ab_join_sine_square.json")).unwrap();

    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let (join_a, join_b) = engine.ab_join(&golden.ts_a, &golden.ts_b);

    assert_profile_match(
        "ab_join/profile_a",
        &join_a.distances,
        &golden.profile_a,
        EPSILON,
    );
    assert_profile_match(
        "ab_join/profile_b",
        &join_b.distances,
        &golden.profile_b,
        EPSILON,
    );
}

// ─── Top-k ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct TopKGolden {
    ts: Vec<f64>,
    m: usize,
    k: usize,
    distances: Vec<Vec<f64>>,
    #[allow(dead_code)]
    indices: Vec<Vec<i64>>,
}

#[test]
fn test_topk_vs_stumpy() {
    eprintln!("Testing Top-k vs stumpy...");
    let golden: TopKGolden = serde_json::from_str(&load_json("topk_sine_wave.json")).unwrap();

    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let topk = engine.compute_topk(&golden.ts, golden.k);

    assert_eq!(topk.k, golden.k, "k mismatch");
    assert_eq!(
        topk.distances.len(),
        golden.distances.len(),
        "number of subsequences mismatch"
    );

    // Compare top-1 (nearest neighbor) distances — should match exactly
    let rust_top1: Vec<f64> = topk.distances.iter().map(|d| d[0]).collect();
    let stumpy_top1: Vec<f64> = golden.distances.iter().map(|d| d[0]).collect();
    assert_profile_match("topk/top1_distances", &rust_top1, &stumpy_top1, EPSILON);

    // Compare all k distances per subsequence
    assert_topk_match(
        "topk/all_distances",
        &topk.distances,
        &golden.distances,
        EPSILON,
    );
}

// ─── Discords ─────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct DiscordEntry {
    idx: usize,
    distance: f64,
}

#[derive(Deserialize)]
struct DiscordsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
    discords: Vec<DiscordEntry>,
}

#[test]
fn test_discords_vs_stumpy() {
    eprintln!("Testing Discord detection vs stumpy...");
    let golden: DiscordsGolden =
        serde_json::from_str(&load_json("discords_synthetic.json")).unwrap();

    // First: verify our STOMP matches stumpy's profile on this anomalous signal
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match(
        "discords/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    // Second: run find_discords and compare top discords
    let k = golden.discords.len();
    let our_discords = motif_rs::find_discords(&mp, k);

    assert_eq!(
        our_discords.len(),
        k,
        "discord count mismatch: got {}, expected {k}",
        our_discords.len()
    );

    // The top discord should be near the injected anomaly
    // Note: exact indices may differ due to tie-breaking, but the top discord
    // should be close to the same position and have the same distance
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    for (i, (ours, theirs)) in our_discords.iter().zip(&golden.discords).enumerate() {
        let idx_diff = (ours.idx as isize - theirs.idx as isize).unsigned_abs();
        let dist_diff = (ours.distance - theirs.distance).abs();
        assert!(
            idx_diff <= ez,
            "discord #{i}: index mismatch: ours={}, stumpy={}, diff={idx_diff} > ez={ez}",
            ours.idx,
            theirs.idx
        );
        assert!(
            dist_diff < EPSILON,
            "discord #{i}: distance mismatch: ours={}, stumpy={}, diff={dist_diff:.2e}",
            ours.distance,
            theirs.distance
        );
    }
    eprintln!("  discords: all {k} discords match within exclusion zone and epsilon");
}

// ─── Motifs ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MotifsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
    #[allow(dead_code)]
    motifs: Vec<serde_json::Value>,
}

#[test]
fn test_motifs_profile_vs_stumpy() {
    eprintln!("Testing Motifs (profile validation) vs stumpy...");
    let golden: MotifsGolden = serde_json::from_str(&load_json("motifs_synthetic.json")).unwrap();

    // Verify our STOMP matches stumpy's profile on the motif signal
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match(
        "motifs/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    // Run find_motifs to verify it doesn't panic and returns reasonable results
    let our_motifs = motif_rs::find_motifs(&mp, 3);
    eprintln!(
        "  motifs: found {} motifs (stumpy found {} with its different criteria)",
        our_motifs.len(),
        golden.motifs.len()
    );

    // Verify motifs are sorted by distance (ascending)
    for w in our_motifs.windows(2) {
        assert!(
            w[0].distance <= w[1].distance,
            "motifs not sorted: {} > {}",
            w[0].distance,
            w[1].distance
        );
    }

    // Verify motif distances are finite and positive
    for m in &our_motifs {
        assert!(m.distance.is_finite(), "motif distance is not finite");
        assert!(m.distance >= 0.0, "motif distance is negative");
        assert_ne!(m.idx_a, m.idx_b, "motif pair should have distinct indices");
    }
}

// ─── FLUSS ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct FlussGolden {
    ts: Vec<f64>,
    m: usize,
    #[allow(dead_code)]
    n: usize,
    #[allow(dead_code)]
    #[serde(rename = "L")]
    l: usize,
    profile_index: Vec<i64>,
    cac: Vec<f64>,
    #[allow(dead_code)]
    regime_locs: Vec<usize>,
}

#[test]
fn test_fluss_cac_vs_stumpy() {
    eprintln!("Testing FLUSS CAC vs stumpy...");
    let golden: FlussGolden = serde_json::from_str(&load_json("fluss_regime_change.json")).unwrap();

    // Construct a MatrixProfile from stumpy's profile_index so we test the
    // FLUSS algorithm in isolation from any STOMP tie-breaking differences.
    let n_subs = golden.profile_index.len();
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    let mut mp = MatrixProfile::new(n_subs, golden.m, ez);
    for (i, &idx) in golden.profile_index.iter().enumerate() {
        mp.profile_index[i] = idx as usize;
    }

    let seg = motif_rs::fluss(&mp, 1);
    let excl_zone = 5 * golden.m;

    // Length should match
    assert_eq!(
        seg.cac.len(),
        golden.cac.len(),
        "FLUSS CAC length mismatch: ours={}, stumpy={}",
        seg.cac.len(),
        golden.cac.len()
    );

    // All values should be in [0, 1]
    for (i, &v) in seg.cac.iter().enumerate() {
        assert!((0.0..=1.0).contains(&v), "CAC[{i}] = {v} out of [0, 1]");
    }

    // Edges should be nullified to 1.0
    for i in 0..excl_zone.min(seg.cac.len()) {
        assert!(
            (seg.cac[i] - 1.0).abs() < 1e-10,
            "FLUSS CAC not nullified at left edge index {i}: {}",
            seg.cac[i]
        );
    }
    for i in (n_subs - excl_zone).max(0)..n_subs {
        assert!(
            (seg.cac[i] - 1.0).abs() < 1e-10,
            "FLUSS CAC not nullified at right edge index {i}: {}",
            seg.cac[i]
        );
    }
    eprintln!("  fluss: edge nullification verified");

    // Our CAC and stumpy's CAC should have the same shape (Spearman rank
    // correlation) even though absolute values differ due to normalization.
    // Both should identify the same regime boundary position.
    // Note: stumpy normalizes with a beta distribution IAC, we use min(i+1, n-i).
    let valid_ours: Vec<f64> = seg.cac[excl_zone..n_subs - excl_zone].to_vec();
    let valid_stumpy: Vec<f64> = golden.cac[excl_zone..n_subs - excl_zone].to_vec();

    // Find the argmin of both CAC curves — should be in similar positions
    let our_min_idx = valid_ours
        .iter()
        .enumerate()
        .min_by(|a, b| a.1.partial_cmp(b.1).unwrap())
        .map(|(i, _)| i + excl_zone)
        .unwrap();
    let stumpy_min_idx = valid_stumpy
        .iter()
        .enumerate()
        .min_by(|a, b| a.1.partial_cmp(b.1).unwrap())
        .map(|(i, _)| i + excl_zone)
        .unwrap();

    let idx_diff = (our_min_idx as isize - stumpy_min_idx as isize).unsigned_abs();
    eprintln!(
        "  fluss/cac: our argmin={our_min_idx}, stumpy argmin={stumpy_min_idx}, diff={idx_diff}"
    );

    // Argmin positions should be close (within 2*m of each other)
    let tolerance = 2 * golden.m;
    assert!(
        idx_diff <= tolerance,
        "FLUSS CAC argmin differs: ours={our_min_idx}, stumpy={stumpy_min_idx}, \
         diff={idx_diff} > tolerance={tolerance}"
    );

    // Pearson correlation between the two CACs should be high
    let n_valid = valid_ours.len() as f64;
    let mean_ours = valid_ours.iter().sum::<f64>() / n_valid;
    let mean_stumpy = valid_stumpy.iter().sum::<f64>() / n_valid;

    let mut cov = 0.0;
    let mut var_ours = 0.0;
    let mut var_stumpy = 0.0;
    for (o, s) in valid_ours.iter().zip(&valid_stumpy) {
        let do_ = o - mean_ours;
        let ds = s - mean_stumpy;
        cov += do_ * ds;
        var_ours += do_ * do_;
        var_stumpy += ds * ds;
    }
    let correlation = cov / (var_ours.sqrt() * var_stumpy.sqrt());
    eprintln!("  fluss/cac: Pearson correlation with stumpy = {correlation:.4}");

    assert!(
        correlation > 0.85,
        "FLUSS CAC correlation with stumpy too low: {correlation:.4} (expected > 0.85)"
    );
}

// ─── End-to-end FLUSS with our STOMP ─────────────────────────────────────────

#[test]
fn test_fluss_end_to_end() {
    eprintln!("Testing FLUSS end-to-end (our STOMP + our FLUSS)...");
    let golden: FlussGolden = serde_json::from_str(&load_json("fluss_regime_change.json")).unwrap();

    // Run our full pipeline: STOMP → FLUSS
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);
    let seg = motif_rs::fluss(&mp, 1);

    // The CAC minimum should be near the regime change at index ~500
    // (the signal transitions from sine to sawtooth at ts[500]).
    // Convention: LOW CAC = regime boundary.
    let excl_zone = 5 * golden.m;
    let valid_cac: Vec<(usize, f64)> = seg
        .cac
        .iter()
        .enumerate()
        .filter(|(i, _)| *i >= excl_zone && *i < seg.cac.len() - excl_zone)
        .map(|(i, &v)| (i, v))
        .collect();

    let (min_idx, min_val) = valid_cac
        .iter()
        .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
        .unwrap();

    eprintln!("  fluss/e2e: CAC minimum at index {min_idx} (value = {min_val:.4})");

    // The minimum should be in the neighborhood of the regime change
    // Allow a wide margin since STOMP tie-breaking may shift the exact position
    // and subsequence boundary is at ~475-500 for m=25
    let regime_change = 500;
    let margin = 100; // ±100 indices
    assert!(
        (*min_idx as isize - regime_change as isize).unsigned_abs() < margin,
        "FLUSS e2e: CAC minimum at {min_idx}, expected near {regime_change} (±{margin})"
    );
}

// ─── Snippets ────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct SnippetsGolden {
    ts: Vec<f64>,
    m: usize,
    k: usize,
    indices: Vec<usize>,
    profiles: Vec<Vec<f64>>,
    fractions: Vec<f64>,
    areas: Vec<f64>,
    regimes: Vec<usize>,
}

#[test]
fn test_snippets_vs_stumpy() {
    eprintln!("Testing Snippets vs stumpy...");
    let golden: SnippetsGolden =
        serde_json::from_str(&load_json("snippets_multi_regime.json")).unwrap();

    let result = find_snippets(&golden.ts, golden.m, golden.k);

    // Indices should match exactly
    assert_eq!(
        result.indices, golden.indices,
        "snippets: indices mismatch: ours={:?}, stumpy={:?}",
        result.indices, golden.indices
    );
    eprintln!("  snippets/indices: match exactly {:?}", result.indices);

    // Profiles should match within epsilon
    assert_eq!(result.profiles.len(), golden.profiles.len());
    for (i, (ours, theirs)) in result.profiles.iter().zip(&golden.profiles).enumerate() {
        assert_profile_match(&format!("snippets/profile_{i}"), ours, theirs, EPSILON);
    }

    // Fractions should match within epsilon
    for (i, (ours, theirs)) in result.fractions.iter().zip(&golden.fractions).enumerate() {
        let diff = (ours - theirs).abs();
        assert!(
            diff < EPSILON,
            "snippets/fraction_{i}: mismatch: ours={ours}, stumpy={theirs}, diff={diff:.2e}"
        );
    }
    eprintln!(
        "  snippets/fractions: {:?} (stumpy: {:?})",
        result.fractions, golden.fractions
    );

    // Areas should match within epsilon
    for (i, (ours, theirs)) in result.areas.iter().zip(&golden.areas).enumerate() {
        let diff = (ours - theirs).abs();
        // Areas are sums over n_subs elements, so allow proportionally larger tolerance
        let area_eps = EPSILON * golden.ts.len() as f64;
        assert!(
            diff < area_eps,
            "snippets/area_{i}: mismatch: ours={ours}, stumpy={theirs}, diff={diff:.2e}"
        );
    }
    eprintln!("  snippets/areas: match within tolerance");

    // Regimes should match exactly (since profiles and indices match)
    assert_eq!(result.regimes, golden.regimes, "snippets: regimes mismatch");
    eprintln!("  snippets/regimes: match exactly");
}

// ─── MPdist ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MpdistGolden {
    ts_a: Vec<f64>,
    ts_b: Vec<f64>,
    m: usize,
    dist_default: f64,
    dist_custom_005: f64,
    dist_self: f64,
}

#[test]
fn test_mpdist_vs_stumpy() {
    eprintln!("Testing MPdist vs stumpy...");
    let golden: MpdistGolden = serde_json::from_str(&load_json("mpdist_sine_mixed.json")).unwrap();

    // Test default percentage
    let d_default = mpdist::<ZNormalizedEuclidean>(&golden.ts_a, &golden.ts_b, golden.m, None);
    let diff_default = (d_default - golden.dist_default).abs();
    eprintln!(
        "  mpdist/default: ours={d_default:.6}, stumpy={:.6}, diff={diff_default:.2e}",
        golden.dist_default
    );
    assert!(
        diff_default < EPSILON,
        "mpdist default: diff={diff_default:.2e} > epsilon={EPSILON:.0e}"
    );

    // Test custom percentage=0.05
    let d_custom = mpdist::<ZNormalizedEuclidean>(&golden.ts_a, &golden.ts_b, golden.m, Some(0.05));
    let diff_custom = (d_custom - golden.dist_custom_005).abs();
    eprintln!(
        "  mpdist/custom_005: ours={d_custom:.6}, stumpy={:.6}, diff={diff_custom:.2e}",
        golden.dist_custom_005
    );
    assert!(
        diff_custom < EPSILON,
        "mpdist custom 0.05: diff={diff_custom:.2e} > epsilon={EPSILON:.0e}"
    );

    // Test self-distance (should be ~0)
    let d_self = mpdist::<ZNormalizedEuclidean>(&golden.ts_a, &golden.ts_a, golden.m, None);
    eprintln!(
        "  mpdist/self: ours={d_self:.6}, stumpy={:.6}",
        golden.dist_self
    );
    assert!(
        d_self < 1e-4,
        "mpdist self-distance should be ~0, got {d_self}"
    );
}

// ─── SCRUMP ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct ScrumpGolden {
    ts: Vec<f64>,
    m: usize,
    exact_profile: Vec<f64>,
    #[allow(dead_code)]
    approx_profile_100: Vec<f64>,
}

#[test]
fn test_scrump_exact_vs_stumpy() {
    eprintln!("Testing SCRUMP (percentage=1.0 → exact STOMP) vs stumpy...");
    let golden: ScrumpGolden = serde_json::from_str(&load_json("scrump_sine_wave.json")).unwrap();

    // SCRUMP at percentage=1.0 should match exact STOMP exactly
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.scrump(&golden.ts, 1.0);

    assert_profile_match(
        "scrump/exact_profile",
        &mp.profile,
        &golden.exact_profile,
        EPSILON,
    );
}

// ─── Ostinato ────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct OstinatoGolden {
    ts_list: Vec<Vec<f64>>,
    m: usize,
    radius: f64,
    ts_idx: usize,
    subseq_idx: usize,
}

#[test]
fn test_ostinato_vs_stumpy() {
    eprintln!("Testing Ostinato vs stumpy...");
    let golden: OstinatoGolden =
        serde_json::from_str(&load_json("ostinato_consensus.json")).unwrap();

    let ts_refs: Vec<&[f64]> = golden.ts_list.iter().map(|v| v.as_slice()).collect();
    let result = ostinato::<ZNormalizedEuclidean>(&ts_refs, golden.m);

    eprintln!(
        "  ostinato: ours=(radius={:.6}, ts_idx={}, subseq_idx={}), \
         stumpy=(radius={:.6}, ts_idx={}, subseq_idx={})",
        result.radius,
        result.ts_index,
        result.subsequence_index,
        golden.radius,
        golden.ts_idx,
        golden.subseq_idx,
    );

    // Radius should be close to stumpy's
    let radius_diff = (result.radius - golden.radius).abs();
    assert!(
        radius_diff < EPSILON,
        "ostinato radius: diff={radius_diff:.2e} > epsilon={EPSILON:.0e}"
    );

    // Series index should match
    assert_eq!(
        result.ts_index, golden.ts_idx,
        "ostinato ts_index mismatch: ours={}, stumpy={}",
        result.ts_index, golden.ts_idx
    );

    // Subsequence index should match (or be within exclusion zone)
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    let idx_diff = result.subsequence_index.abs_diff(golden.subseq_idx);
    assert!(
        idx_diff <= ez,
        "ostinato subseq_idx: ours={}, stumpy={}, diff={idx_diff} > ez={ez}",
        result.subsequence_index,
        golden.subseq_idx,
    );
}

// ─── STIMP ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct StimpGolden {
    ts: Vec<f64>,
    min_m: usize,
    max_m: usize,
    windows: Vec<usize>,
    profiles: Vec<Vec<f64>>,
    #[allow(dead_code)]
    indices: Vec<Vec<i64>>,
}

#[test]
fn test_stimp_vs_stumpy() {
    eprintln!("Testing STIMP vs stumpy...");
    let golden: StimpGolden = serde_json::from_str(&load_json("stimp_pan_profile.json")).unwrap();

    // Use exact STOMP (percentage=None) for precise comparison
    let pan = stimp::<ZNormalizedEuclidean>(&golden.ts, golden.min_m, golden.max_m, Some(1), None);

    // Window sizes should match
    assert_eq!(pan.windows, golden.windows, "STIMP window sizes mismatch");

    // Compare normalized profiles for each window size
    for (wi, m) in pan.windows.iter().enumerate() {
        assert_profile_match(
            &format!("stimp/profile_m{m}"),
            &pan.profiles[wi],
            &golden.profiles[wi],
            EPSILON,
        );
    }
    eprintln!(
        "  stimp: all {} window sizes match within epsilon",
        pan.windows.len()
    );
}

// ─── Chains ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct ChainsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    profile_index: Vec<i64>,
    left_profile_index: Vec<i64>,
    right_profile_index: Vec<i64>,
    longest_chain: Vec<i64>,
    all_chains: Vec<Vec<i64>>,
}

#[test]
fn test_chains_vs_stumpy() {
    eprintln!("Testing Chains (ALLC) vs stumpy...");
    let golden: ChainsGolden = serde_json::from_str(&load_json("chains_sine_wave.json")).unwrap();

    // Build a MatrixProfile from stumpy's data to test chains in isolation
    let n_subs = golden.profile.len();
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    let mut mp = MatrixProfile::new(n_subs, golden.m, ez);
    for i in 0..n_subs {
        mp.profile[i] = golden.profile[i];
        mp.profile_index[i] = golden.profile_index[i] as usize;
        mp.left_profile_index[i] = golden.left_profile_index[i] as usize;
        mp.right_profile_index[i] = golden.right_profile_index[i] as usize;
    }

    let result = allc(&mp);

    // The longest chain should match stumpy's unanchored chain
    let stumpy_longest: Vec<usize> = golden.longest_chain.iter().map(|&x| x as usize).collect();

    eprintln!(
        "  chains: ours longest len={}, stumpy longest len={}",
        result.longest.len(),
        stumpy_longest.len()
    );
    eprintln!(
        "  chains: ours longest = {:?}",
        &result.longest.indices[..result.longest.len().min(10)]
    );
    eprintln!(
        "  chains: stumpy longest = {:?}",
        &stumpy_longest[..stumpy_longest.len().min(10)]
    );

    // Chain length should match
    assert_eq!(
        result.longest.len(),
        stumpy_longest.len(),
        "chains: longest chain length mismatch: ours={}, stumpy={}",
        result.longest.len(),
        stumpy_longest.len()
    );

    // Chain indices should match
    assert_eq!(
        result.longest.indices, stumpy_longest,
        "chains: longest chain indices mismatch"
    );

    // Verify all chains have strictly increasing indices
    for (ci, chain) in result.chains.iter().enumerate() {
        for w in chain.indices.windows(2) {
            assert!(
                w[0] < w[1],
                "chains[{ci}]: indices not strictly increasing: {} >= {}",
                w[0],
                w[1]
            );
        }
    }

    // Verify chain count is reasonable
    let stumpy_chain_count = golden.all_chains.len();
    eprintln!(
        "  chains: ours found {} chains, stumpy found {}",
        result.chains.len(),
        stumpy_chain_count
    );
}

#[test]
fn test_chains_end_to_end() {
    eprintln!("Testing Chains end-to-end (our STOMP + our ALLC)...");
    let golden: ChainsGolden = serde_json::from_str(&load_json("chains_sine_wave.json")).unwrap();

    // Run our full pipeline
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    // Verify STOMP profile matches
    assert_profile_match(
        "chains_e2e/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    let result = allc(&mp);

    // The chain should have length >= 2 for a periodic signal
    assert!(
        result.longest.len() >= 2,
        "chains e2e: expected chain length >= 2, got {}",
        result.longest.len()
    );
    eprintln!(
        "  chains e2e: longest chain length = {}",
        result.longest.len()
    );
}

// ─── MASS / Match ────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MatchGolden {
    ts: Vec<f64>,
    query: Vec<f64>,
    #[allow(dead_code)]
    query_start: usize,
    #[allow(dead_code)]
    query_len: usize,
    match_distances: Vec<f64>,
    match_indices: Vec<i64>,
    mass_profile: Vec<f64>,
}

#[test]
fn test_mass_vs_stumpy() {
    eprintln!("Testing MASS distance profile vs stumpy...");
    let golden: MatchGolden = serde_json::from_str(&load_json("match_sine_wave.json")).unwrap();

    let dp = mass(&golden.query, &golden.ts);

    assert_profile_match("mass/distance_profile", &dp, &golden.mass_profile, EPSILON);
}

#[test]
fn test_match_vs_stumpy() {
    eprintln!("Testing match (find_matches) vs stumpy...");
    let golden: MatchGolden = serde_json::from_str(&load_json("match_sine_wave.json")).unwrap();

    // Use stumpy's default threshold (None) to match stumpy.match behavior
    let matches = find_matches(&golden.query, &golden.ts, None, None);

    let stumpy_indices: Vec<usize> = golden.match_indices.iter().map(|&x| x as usize).collect();

    eprintln!(
        "  match: ours found {} matches, stumpy found {}",
        matches.len(),
        stumpy_indices.len()
    );

    // The number of matches should be similar
    // (may differ slightly due to threshold computation precision)
    let count_diff = (matches.len() as isize - stumpy_indices.len() as isize).unsigned_abs();
    assert!(
        count_diff <= 2,
        "match: count mismatch too large: ours={}, stumpy={}, diff={}",
        matches.len(),
        stumpy_indices.len(),
        count_diff
    );

    // Compare matched indices — our matches should cover the same positions
    // The first match should be at or very near stumpy's first match
    if !matches.is_empty() && !stumpy_indices.is_empty() {
        let our_first = matches[0].index;
        let stumpy_first = stumpy_indices[0];
        let ez = (golden.query.len() as f64 / 4.0).ceil() as usize;
        let idx_diff = our_first.abs_diff(stumpy_first);
        assert!(
            idx_diff <= ez,
            "match: first match index mismatch: ours={}, stumpy={}, diff={} > ez={}",
            our_first,
            stumpy_first,
            idx_diff,
            ez
        );
        eprintln!(
            "  match: first match: ours=({}, {:.6}), stumpy=({}, {:.6})",
            our_first, matches[0].distance, stumpy_first, golden.match_distances[0]
        );
    }

    // Compare distances for matched indices (first few)
    let n_compare = matches.len().min(stumpy_indices.len()).min(5);
    for i in 0..n_compare {
        let dist_diff = (matches[i].distance - golden.match_distances[i]).abs();
        eprintln!(
            "  match[{i}]: ours=({}, {:.6}), stumpy=({}, {:.6}), dist_diff={:.2e}",
            matches[i].index,
            matches[i].distance,
            stumpy_indices[i],
            golden.match_distances[i],
            dist_diff
        );
    }

    // Matches should be sorted by distance
    for w in matches.windows(2) {
        assert!(
            w[0].distance <= w[1].distance + 1e-10,
            "match: not sorted by distance: {} > {}",
            w[0].distance,
            w[1].distance
        );
    }
}

// ─── MSTUMP ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MstumpGolden {
    ts: Vec<Vec<f64>>,
    m: usize,
    d: usize,
    #[allow(dead_code)]
    n: usize,
    profile: Vec<Vec<f64>>,
    profile_index: Vec<Vec<i64>>,
}

#[test]
fn test_mstump_vs_stumpy() {
    eprintln!("Testing MSTUMP vs stumpy...");
    let golden: MstumpGolden = serde_json::from_str(&load_json("mstump_multi_dim.json")).unwrap();

    let ts_refs: Vec<&[f64]> = golden.ts.iter().map(|v| v.as_slice()).collect();
    let result = mstump(&ts_refs, golden.m);

    assert_eq!(result.d, golden.d);
    assert_eq!(result.m, golden.m);
    assert_eq!(result.profile.len(), golden.d);

    // Compare distance profiles for each dimension-count row
    for k in 0..golden.d {
        assert_profile_match(
            &format!("mstump/profile_row{k}"),
            &result.profile[k],
            &golden.profile[k],
            EPSILON,
        );
    }

    // Compare NN indices for row 0 (1D profile)
    let stumpy_idx: Vec<usize> = golden.profile_index[0]
        .iter()
        .map(|&x| x as usize)
        .collect();
    let mut idx_mismatches = 0;
    for (j, (&ours, &theirs)) in result.profile_index[0].iter().zip(&stumpy_idx).enumerate() {
        if ours != theirs {
            // Allow index mismatch if both distances are very close
            let d_ours = result.profile[0][j];
            let d_theirs = golden.profile[0][j];
            if (d_ours - d_theirs).abs() < EPSILON {
                idx_mismatches += 1;
            } else {
                panic!(
                    "mstump: index mismatch at row 0, pos {j}: ours={ours}, stumpy={theirs}, \
                     d_ours={d_ours}, d_stumpy={d_theirs}"
                );
            }
        }
    }
    eprintln!(
        "  mstump/row0_indices: {} mismatches (with equivalent distances)",
        idx_mismatches
    );
}

// ─── Subspace ────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
#[allow(dead_code)]
struct SubspaceGolden {
    ts: Vec<Vec<f64>>,
    m: usize,
    d: usize,
    subseq_idx: usize,
    nn_idx: usize,
    dims_n1: Vec<usize>,
    dims_n2: Vec<usize>,
    dims_n3: Vec<usize>,
}

#[test]
fn test_subspace_vs_stumpy() {
    eprintln!("Testing subspace vs stumpy...");
    let golden: SubspaceGolden =
        serde_json::from_str(&load_json("subspace_multi_dim.json")).unwrap();

    let ts_refs: Vec<&[f64]> = golden.ts.iter().map(|v| v.as_slice()).collect();

    for (k, expected) in [
        (1, &golden.dims_n1),
        (2, &golden.dims_n2),
        (3, &golden.dims_n3),
    ] {
        let result = subspace(&ts_refs, golden.m, golden.subseq_idx, golden.nn_idx, k);
        assert_eq!(
            &result, expected,
            "subspace(k={k}): ours={result:?}, stumpy={expected:?}"
        );
        eprintln!("  subspace(k={k}): {result:?} == {expected:?} ✓");
    }
}

// ─── MDL ─────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MdlGolden {
    ts: Vec<Vec<f64>>,
    m: usize,
    d: usize,
    subseq_idx: usize,
    nn_idx_per_dim: Vec<usize>,
    bit_sizes: Vec<f64>,
    dim_orderings: Vec<Vec<usize>>,
}

#[test]
fn test_mdl_vs_stumpy() {
    eprintln!("Testing MDL vs stumpy...");
    let golden: MdlGolden = serde_json::from_str(&load_json("mdl_multi_dim.json")).unwrap();

    let ts_refs: Vec<&[f64]> = golden.ts.iter().map(|v| v.as_slice()).collect();

    // stumpy.mdl(T, m, subseq_idx=[idx]*d, nn_idx=nn_idx_per_dim)
    let subseq_idx_arr: Vec<usize> = vec![golden.subseq_idx; golden.d];
    let (bit_sizes, subspaces) = mdl(&ts_refs, golden.m, &subseq_idx_arr, &golden.nn_idx_per_dim);

    assert_eq!(bit_sizes.len(), golden.d);
    for (k, (ours, theirs)) in bit_sizes.iter().zip(&golden.bit_sizes).enumerate() {
        let diff = (ours - theirs).abs();
        assert!(
            diff < EPSILON,
            "mdl bit_sizes[{k}]: ours={ours}, stumpy={theirs}, diff={diff:.2e}"
        );
        eprintln!("  mdl/bit_sizes[{k}]: ours={ours:.4}, stumpy={theirs:.4}, diff={diff:.2e}");
    }

    // Verify subspace dimension orderings
    for (k, (ours, theirs)) in subspaces.iter().zip(&golden.dim_orderings).enumerate() {
        assert_eq!(
            ours, theirs,
            "mdl dim_orderings[{k}]: ours={ours:?}, stumpy={theirs:?}"
        );
        eprintln!("  mdl/dims[{k}]: {ours:?} == {theirs:?} ✓");
    }

    // Verify optimal k matches (argmin of bit sizes)
    let our_opt_k = bit_sizes
        .iter()
        .enumerate()
        .min_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())
        .map(|(i, _)| i + 1)
        .unwrap();
    let stumpy_opt_k = golden
        .bit_sizes
        .iter()
        .enumerate()
        .min_by(|(_, a), (_, b)| a.partial_cmp(b).unwrap())
        .map(|(i, _)| i + 1)
        .unwrap();
    assert_eq!(
        our_opt_k, stumpy_opt_k,
        "mdl: optimal k mismatch: ours={our_opt_k}, stumpy={stumpy_opt_k}"
    );
    eprintln!("  mdl/optimal_k: {our_opt_k}");
}

// ─── MMOTIFS ─────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
#[allow(dead_code)]
struct MmotifEntry {
    idx: usize,
    nn_idx: usize,
    distance: f64,
    subspace: Vec<usize>,
    mdl_bit_sizes: Vec<f64>,
}

#[derive(Deserialize)]
struct MmotifsGolden {
    ts: Vec<Vec<f64>>,
    m: usize,
    d: usize,
    motifs: Vec<MmotifEntry>,
}

#[test]
fn test_mmotifs_structural() {
    eprintln!("Testing mmotifs structural properties...");
    let golden: MmotifsGolden = serde_json::from_str(&load_json("mmotifs_multi_dim.json")).unwrap();

    let ts_refs: Vec<&[f64]> = golden.ts.iter().map(|v| v.as_slice()).collect();
    let profile = mstump(&ts_refs, golden.m);

    let motifs = mmotifs(&ts_refs, golden.m, &profile, 3);

    assert!(!motifs.is_empty(), "mmotifs should find at least one motif");

    for (i, motif) in motifs.iter().enumerate() {
        // k should be valid
        assert!(
            motif.k >= 1 && motif.k <= golden.d,
            "motif[{i}].k={} out of range [1, {}]",
            motif.k,
            golden.d
        );

        // Dimensions length should match k
        assert_eq!(
            motif.dimensions.len(),
            motif.k,
            "motif[{i}] dimensions length should match k"
        );

        // Distance should be non-negative and finite
        assert!(
            motif.distance >= 0.0 && motif.distance.is_finite(),
            "motif[{i}].distance={} invalid",
            motif.distance
        );

        // Indices should be distinct
        assert_ne!(
            motif.idx, motif.nn_idx,
            "motif[{i}] should have distinct indices"
        );

        // MDL bit sizes should be non-negative
        assert_eq!(
            motif.mdl_bit_sizes.len(),
            golden.d,
            "motif[{i}] mdl_bit_sizes should have d entries"
        );
        for (k, &bs) in motif.mdl_bit_sizes.iter().enumerate() {
            assert!(bs >= 0.0, "motif[{i}].mdl_bit_sizes[{k}]={bs} negative");
        }

        eprintln!(
            "  motif[{i}]: idx={}, nn={}, k={}, dims={:?}, dist={:.6}",
            motif.idx, motif.nn_idx, motif.k, motif.dimensions, motif.distance
        );
    }

    // Motifs should be sorted by distance
    for w in motifs.windows(2) {
        assert!(
            w[0].distance <= w[1].distance + 1e-10,
            "mmotifs not sorted: {} > {}",
            w[0].distance,
            w[1].distance
        );
    }

    // Compare against stumpy's motif distances — our motifs should have
    // similar (not necessarily identical) distances since motif selection
    // may differ between our algorithm and stumpy's mmotifs
    if !golden.motifs.is_empty() && !motifs.is_empty() {
        // Both should find motifs with small distances in this periodic signal
        eprintln!(
            "  mmotifs: stumpy found {} motifs, we found {}",
            golden.motifs.len(),
            motifs.len()
        );
        eprintln!(
            "  mmotifs: stumpy motif[0] dist={:.6}, ours motif[0] dist={:.6}",
            golden.motifs[0].distance, motifs[0].distance
        );
    }
}
