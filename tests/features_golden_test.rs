//! Golden tests for new motif-rs features validated against stumpy reference data.
//!
//! Each test loads a JSON file generated by `scripts/generate_golden_features.py`
//! and compares our implementation's output against stumpy's reference output.

use motif_rs::{AampEngine, EuclideanEngine, MatrixProfile, MatrixProfileConfig};
use serde::Deserialize;
use std::fs;

const EPSILON: f64 = 1e-6;

// ─── helpers ──────────────────────────────────────────────────────────────────

fn load_json(filename: &str) -> String {
    let path = format!("tests/golden_data/{filename}");
    fs::read_to_string(&path).unwrap_or_else(|_| {
        panic!(
            "Golden data file not found: {path}. Run: python scripts/generate_golden_features.py"
        )
    })
}

/// Treat values > 1e300 as infinity (JSON uses 1e308 sentinel for inf).
fn is_sentinel_inf(v: f64) -> bool {
    v.is_infinite() || v > 1e300
}

fn assert_profile_match(name: &str, rust: &[f64], stumpy: &[f64], epsilon: f64) {
    assert_eq!(
        rust.len(),
        stumpy.len(),
        "{name}: length mismatch: rust={} vs stumpy={}",
        rust.len(),
        stumpy.len()
    );

    let mut max_diff = 0.0_f64;
    let mut max_diff_idx = 0;

    for (i, (r, s)) in rust.iter().zip(stumpy).enumerate() {
        if is_sentinel_inf(*r) && is_sentinel_inf(*s) {
            continue;
        }
        let diff = (r - s).abs();
        if diff > max_diff {
            max_diff = diff;
            max_diff_idx = i;
        }
    }

    assert!(
        max_diff < epsilon,
        "{name}: max diff = {max_diff:.2e} at index {max_diff_idx} \
         (rust={}, stumpy={}), epsilon={epsilon:.0e}",
        rust[max_diff_idx],
        stumpy[max_diff_idx],
    );

    eprintln!("  {name}: max_diff = {max_diff:.2e} (epsilon = {epsilon:.0e})");
}

// ─── AAMP ─────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct AampGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
}

#[test]
fn test_aamp_vs_stumpy() {
    eprintln!("Testing AAMP (non-normalized Euclidean) vs stumpy...");
    let golden: AampGolden = serde_json::from_str(&load_json("aamp_sine_wave.json")).unwrap();

    let engine = AampEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match("aamp/profile", &mp.profile, &golden.profile, EPSILON);
}

// ─── AB-Join ──────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct AbJoinGolden {
    ts_a: Vec<f64>,
    ts_b: Vec<f64>,
    m: usize,
    #[allow(dead_code)]
    n_a: usize,
    #[allow(dead_code)]
    n_b: usize,
    profile_a: Vec<f64>,
    #[allow(dead_code)]
    index_a: Vec<i64>,
    profile_b: Vec<f64>,
    #[allow(dead_code)]
    index_b: Vec<i64>,
}

#[test]
fn test_ab_join_vs_stumpy() {
    eprintln!("Testing AB-Join vs stumpy...");
    let golden: AbJoinGolden =
        serde_json::from_str(&load_json("ab_join_sine_square.json")).unwrap();

    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let (join_a, join_b) = engine.ab_join(&golden.ts_a, &golden.ts_b);

    assert_profile_match(
        "ab_join/profile_a",
        &join_a.distances,
        &golden.profile_a,
        EPSILON,
    );
    assert_profile_match(
        "ab_join/profile_b",
        &join_b.distances,
        &golden.profile_b,
        EPSILON,
    );
}

// ─── Top-k ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct TopKGolden {
    ts: Vec<f64>,
    m: usize,
    k: usize,
    distances: Vec<Vec<f64>>,
    #[allow(dead_code)]
    indices: Vec<Vec<i64>>,
}

#[test]
fn test_topk_vs_stumpy() {
    eprintln!("Testing Top-k vs stumpy...");
    let golden: TopKGolden = serde_json::from_str(&load_json("topk_sine_wave.json")).unwrap();

    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let topk = engine.compute_topk(&golden.ts, golden.k);

    assert_eq!(topk.k, golden.k, "k mismatch");
    assert_eq!(
        topk.distances.len(),
        golden.distances.len(),
        "number of subsequences mismatch"
    );

    // Compare top-1 (nearest neighbor) distances — should match exactly
    let rust_top1: Vec<f64> = topk.distances.iter().map(|d| d[0]).collect();
    let stumpy_top1: Vec<f64> = golden.distances.iter().map(|d| d[0]).collect();
    assert_profile_match("topk/top1_distances", &rust_top1, &stumpy_top1, EPSILON);

    // Compare all k distances per subsequence
    let mut max_diff = 0.0_f64;
    let mut max_diff_pos = (0, 0);
    for (i, (rd, sd)) in topk.distances.iter().zip(&golden.distances).enumerate() {
        assert_eq!(
            rd.len(),
            sd.len(),
            "topk: k-count mismatch at subsequence {i}"
        );
        for (j, (r, s)) in rd.iter().zip(sd).enumerate() {
            if is_sentinel_inf(*r) && is_sentinel_inf(*s) {
                continue;
            }
            let diff = (r - s).abs();
            if diff > max_diff {
                max_diff = diff;
                max_diff_pos = (i, j);
            }
        }
    }
    assert!(
        max_diff < EPSILON,
        "topk/all_distances: max diff = {max_diff:.2e} at ({}, {}), epsilon={EPSILON:.0e}",
        max_diff_pos.0,
        max_diff_pos.1,
    );
    eprintln!("  topk/all_distances: max_diff = {max_diff:.2e} (epsilon = {EPSILON:.0e})");
}

// ─── Discords ─────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct DiscordEntry {
    idx: usize,
    distance: f64,
}

#[derive(Deserialize)]
struct DiscordsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
    discords: Vec<DiscordEntry>,
}

#[test]
fn test_discords_vs_stumpy() {
    eprintln!("Testing Discord detection vs stumpy...");
    let golden: DiscordsGolden =
        serde_json::from_str(&load_json("discords_synthetic.json")).unwrap();

    // First: verify our STOMP matches stumpy's profile on this anomalous signal
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match(
        "discords/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    // Second: run find_discords and compare top discords
    let k = golden.discords.len();
    let our_discords = motif_rs::find_discords(&mp, k);

    assert_eq!(
        our_discords.len(),
        k,
        "discord count mismatch: got {}, expected {k}",
        our_discords.len()
    );

    // The top discord should be near the injected anomaly
    // Note: exact indices may differ due to tie-breaking, but the top discord
    // should be close to the same position and have the same distance
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    for (i, (ours, theirs)) in our_discords.iter().zip(&golden.discords).enumerate() {
        let idx_diff = (ours.idx as isize - theirs.idx as isize).unsigned_abs();
        let dist_diff = (ours.distance - theirs.distance).abs();
        assert!(
            idx_diff <= ez,
            "discord #{i}: index mismatch: ours={}, stumpy={}, diff={idx_diff} > ez={ez}",
            ours.idx,
            theirs.idx
        );
        assert!(
            dist_diff < EPSILON,
            "discord #{i}: distance mismatch: ours={}, stumpy={}, diff={dist_diff:.2e}",
            ours.distance,
            theirs.distance
        );
    }
    eprintln!("  discords: all {k} discords match within exclusion zone and epsilon");
}

// ─── Motifs ───────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct MotifsGolden {
    ts: Vec<f64>,
    m: usize,
    profile: Vec<f64>,
    #[allow(dead_code)]
    profile_index: Vec<i64>,
    #[allow(dead_code)]
    motifs: Vec<serde_json::Value>,
}

#[test]
fn test_motifs_profile_vs_stumpy() {
    eprintln!("Testing Motifs (profile validation) vs stumpy...");
    let golden: MotifsGolden = serde_json::from_str(&load_json("motifs_synthetic.json")).unwrap();

    // Verify our STOMP matches stumpy's profile on the motif signal
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);

    assert_profile_match(
        "motifs/stomp_profile",
        &mp.profile,
        &golden.profile,
        EPSILON,
    );

    // Run find_motifs to verify it doesn't panic and returns reasonable results
    let our_motifs = motif_rs::find_motifs(&mp, 3);
    eprintln!(
        "  motifs: found {} motifs (stumpy found {} with its different criteria)",
        our_motifs.len(),
        golden.motifs.len()
    );

    // Verify motifs are sorted by distance (ascending)
    for w in our_motifs.windows(2) {
        assert!(
            w[0].distance <= w[1].distance,
            "motifs not sorted: {} > {}",
            w[0].distance,
            w[1].distance
        );
    }

    // Verify motif distances are finite and positive
    for m in &our_motifs {
        assert!(m.distance.is_finite(), "motif distance is not finite");
        assert!(m.distance >= 0.0, "motif distance is negative");
        assert_ne!(m.idx_a, m.idx_b, "motif pair should have distinct indices");
    }
}

// ─── FLUSS ────────────────────────────────────────────────────────────────────

#[derive(Deserialize)]
struct FlussGolden {
    ts: Vec<f64>,
    m: usize,
    #[allow(dead_code)]
    n: usize,
    #[allow(dead_code)]
    #[serde(rename = "L")]
    l: usize,
    profile_index: Vec<i64>,
    cac: Vec<f64>,
    #[allow(dead_code)]
    regime_locs: Vec<usize>,
}

#[test]
fn test_fluss_cac_vs_stumpy() {
    eprintln!("Testing FLUSS CAC vs stumpy...");
    let golden: FlussGolden = serde_json::from_str(&load_json("fluss_regime_change.json")).unwrap();

    // Construct a MatrixProfile from stumpy's profile_index so we test the
    // FLUSS algorithm in isolation from any STOMP tie-breaking differences.
    let n_subs = golden.profile_index.len();
    let ez = (golden.m as f64 / 4.0).ceil() as usize;
    let mut mp = MatrixProfile::new(n_subs, golden.m, ez);
    for (i, &idx) in golden.profile_index.iter().enumerate() {
        mp.profile_index[i] = idx as usize;
    }

    let seg = motif_rs::fluss(&mp, 1);
    let excl_zone = 5 * golden.m;

    // Length should match
    assert_eq!(
        seg.cac.len(),
        golden.cac.len(),
        "FLUSS CAC length mismatch: ours={}, stumpy={}",
        seg.cac.len(),
        golden.cac.len()
    );

    // All values should be in [0, 1]
    for (i, &v) in seg.cac.iter().enumerate() {
        assert!((0.0..=1.0).contains(&v), "CAC[{i}] = {v} out of [0, 1]");
    }

    // Edges should be nullified to 1.0
    for i in 0..excl_zone.min(seg.cac.len()) {
        assert!(
            (seg.cac[i] - 1.0).abs() < 1e-10,
            "FLUSS CAC not nullified at left edge index {i}: {}",
            seg.cac[i]
        );
    }
    for i in (n_subs - excl_zone).max(0)..n_subs {
        assert!(
            (seg.cac[i] - 1.0).abs() < 1e-10,
            "FLUSS CAC not nullified at right edge index {i}: {}",
            seg.cac[i]
        );
    }
    eprintln!("  fluss: edge nullification verified");

    // Our CAC and stumpy's CAC should have the same shape (Spearman rank
    // correlation) even though absolute values differ due to normalization.
    // Both should identify the same regime boundary position.
    // Note: stumpy normalizes with a beta distribution IAC, we use min(i+1, n-i).
    let valid_ours: Vec<f64> = seg.cac[excl_zone..n_subs - excl_zone].to_vec();
    let valid_stumpy: Vec<f64> = golden.cac[excl_zone..n_subs - excl_zone].to_vec();

    // Find the argmin of both CAC curves — should be in similar positions
    let our_min_idx = valid_ours
        .iter()
        .enumerate()
        .min_by(|a, b| a.1.partial_cmp(b.1).unwrap())
        .map(|(i, _)| i + excl_zone)
        .unwrap();
    let stumpy_min_idx = valid_stumpy
        .iter()
        .enumerate()
        .min_by(|a, b| a.1.partial_cmp(b.1).unwrap())
        .map(|(i, _)| i + excl_zone)
        .unwrap();

    let idx_diff = (our_min_idx as isize - stumpy_min_idx as isize).unsigned_abs();
    eprintln!(
        "  fluss/cac: our argmin={our_min_idx}, stumpy argmin={stumpy_min_idx}, diff={idx_diff}"
    );

    // Argmin positions should be close (within 2*m of each other)
    let tolerance = 2 * golden.m;
    assert!(
        idx_diff <= tolerance,
        "FLUSS CAC argmin differs: ours={our_min_idx}, stumpy={stumpy_min_idx}, \
         diff={idx_diff} > tolerance={tolerance}"
    );

    // Pearson correlation between the two CACs should be high
    let n_valid = valid_ours.len() as f64;
    let mean_ours = valid_ours.iter().sum::<f64>() / n_valid;
    let mean_stumpy = valid_stumpy.iter().sum::<f64>() / n_valid;

    let mut cov = 0.0;
    let mut var_ours = 0.0;
    let mut var_stumpy = 0.0;
    for (o, s) in valid_ours.iter().zip(&valid_stumpy) {
        let do_ = o - mean_ours;
        let ds = s - mean_stumpy;
        cov += do_ * ds;
        var_ours += do_ * do_;
        var_stumpy += ds * ds;
    }
    let correlation = cov / (var_ours.sqrt() * var_stumpy.sqrt());
    eprintln!("  fluss/cac: Pearson correlation with stumpy = {correlation:.4}");

    assert!(
        correlation > 0.85,
        "FLUSS CAC correlation with stumpy too low: {correlation:.4} (expected > 0.85)"
    );
}

// ─── End-to-end FLUSS with our STOMP ─────────────────────────────────────────

#[test]
fn test_fluss_end_to_end() {
    eprintln!("Testing FLUSS end-to-end (our STOMP + our FLUSS)...");
    let golden: FlussGolden = serde_json::from_str(&load_json("fluss_regime_change.json")).unwrap();

    // Run our full pipeline: STOMP → FLUSS
    let engine = EuclideanEngine::new(MatrixProfileConfig::new(golden.m));
    let mp = engine.compute(&golden.ts);
    let seg = motif_rs::fluss(&mp, 1);

    // The CAC minimum should be near the regime change at index ~500
    // (the signal transitions from sine to sawtooth at ts[500]).
    // Convention: LOW CAC = regime boundary.
    let excl_zone = 5 * golden.m;
    let valid_cac: Vec<(usize, f64)> = seg
        .cac
        .iter()
        .enumerate()
        .filter(|(i, _)| *i >= excl_zone && *i < seg.cac.len() - excl_zone)
        .map(|(i, &v)| (i, v))
        .collect();

    let (min_idx, min_val) = valid_cac
        .iter()
        .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
        .unwrap();

    eprintln!("  fluss/e2e: CAC minimum at index {min_idx} (value = {min_val:.4})");

    // The minimum should be in the neighborhood of the regime change
    // Allow a wide margin since STOMP tie-breaking may shift the exact position
    // and subsequence boundary is at ~475-500 for m=25
    let regime_change = 500;
    let margin = 100; // ±100 indices
    assert!(
        (*min_idx as isize - regime_change as isize).unsigned_abs() < margin,
        "FLUSS e2e: CAC minimum at {min_idx}, expected near {regime_change} (±{margin})"
    );
}
